<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Timeline</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style>
    :root {
      /* ── Primitives ──────────────────────────────────────────────── */
      /* Neutral */
      --_N0: #FFFFFF;
      --_N100: #F7F8F9;
      --_N200: #F1F2F4;
      --_N300: #DCDFE4;
      --_N400: #B3B9C4;
      --_N500: #8590A2;
      --_N600: #758195;
      --_N700: #626F86;
      --_N800: #44546F;
      --_N900: #2C3E5D;
      --_N1000: #172B4D;
      --_N1100: #091E42;
      /* Blue */
      --_B100: #E9F2FF;
      --_B200: #CCE0FF;
      --_B300: #85B8FF;
      --_B400: #579DFF;
      --_B500: #388BFF;
      --_B600: #1D7AFC;
      --_B700: #0C66E4;
      --_B800: #0055CC;
      --_B900: #003366;
      /* Red */
      --_R100: #FFECEB;
      --_R200: #FFD5D2;
      --_R300: #FF9C8F;
      --_R400: #F87462;
      --_R500: #EF5C48;
      --_R600: #E34935;
      --_R700: #CA3521;
      --_R800: #AE2E24;
      --_R900: #5D1F1A;
      /* Orange */
      --_O100: #FFF4EC;
      --_O200: #FEDEC8;
      --_O300: #FEC195;
      --_O400: #FAA53D;
      --_O500: #F18D13;
      --_O600: #C25100;
      --_O700: #A54800;
      --_O800: #702E00;
      /* Lime/Green */
      --_L100: #DCFFF1;
      --_L200: #BAF3DB;
      --_L300: #7EE2B8;
      --_L400: #4BCE97;
      --_L500: #2ABB7F;
      --_L600: #22A06B;
      --_L700: #1F845A;
      --_L800: #216E4E;
      /* Purple */
      --_P100: #F3F0FF;
      --_P200: #DFD8FD;
      --_P300: #B8ACF6;
      --_P400: #9F8FEF;
      --_P500: #8F7EE7;
      --_P600: #8270DB;
      --_P700: #6E5DC6;
      --_P800: #5E4DB2;
      --_P900: #352C63;
      /* Teal */
      --_T100: #E3FAFC;
      --_T200: #C1F0F5;
      --_T300: #8BDBE5;
      --_T400: #60C6D2;
      --_T500: #42B2C2;
      --_T600: #2898AA;
      --_T700: #227D90;
      --_T800: #206B74;
      /* Yellow */
      --_Y100: #FFF7D6;
      --_Y200: #F8E6A0;
      --_Y300: #F5CD47;
      --_Y400: #E2B203;
      --_Y500: #CF9F02;
      --_Y600: #B38600;
      --_Y700: #946F00;
      --_Y800: #7F5F01;
      /* Magenta */
      --_M100: #FFECF8;
      --_M200: #FDD0EC;
      --_M300: #F797D2;
      --_M400: #E774BB;
      --_M500: #DA62AC;
      --_M600: #CD519D;
      --_M700: #AE4787;
      --_M800: #943D73;

      /* ── Semantic: Text ──────────────────────────────────────────── */
      --color-text: #000000;
      --color-text-subtle: var(--eq-text-secondary);
      --color-text-subtlest: var(--_N700);
      --color-text-disabled: rgba(9, 30, 66, 0.31);
      --color-text-inverse: var(--_N0);
      --color-text-brand: var(--eq-purple);
      --color-text-selected: var(--eq-purple);
      --color-text-danger: var(--_R800);
      --color-text-warning: var(--_O800);
      --color-text-success: var(--_L700);
      --color-text-discovery: var(--eq-purple);
      --color-text-information: var(--_B800);

      /* ── Semantic: Icon ──────────────────────────────────────────── */
      --color-icon: var(--_N1000);
      --color-icon-subtle: var(--_N800);
      --color-icon-subtlest: var(--_N700);
      --color-icon-disabled: rgba(9, 30, 66, 0.31);
      --color-icon-inverse: var(--_N0);
      --color-icon-brand: var(--eq-purple);
      --color-icon-selected: var(--eq-purple);
      --color-icon-danger: var(--_R700);
      --color-icon-warning: var(--_O600);
      --color-icon-success: var(--_L600);
      --color-icon-discovery: var(--eq-purple);
      --color-icon-information: var(--_B600);

      /* ── Semantic: Border ────────────────────────────────────────── */
      --color-border: #d0d0d0;
      --color-border-bold: var(--_N600);
      --color-border-input: var(--_N500);
      --color-border-disabled: rgba(9, 30, 66, 0.14);
      --color-border-focused: var(--eq-purple);
      --color-border-selected: var(--eq-purple);
      --color-border-brand: var(--eq-purple);
      --color-border-danger: var(--_R600);
      --color-border-warning: var(--_O600);
      --color-border-success: var(--_L600);
      --color-border-discovery: var(--eq-purple);
      --color-border-information: var(--_B600);

      /* ── Semantic: Background ────────────────────────────────────── */
      --color-bg-neutral: rgba(9, 30, 66, 0.06);
      --color-bg-neutral-hovered: rgba(9, 30, 66, 0.14);
      --color-bg-neutral-pressed: rgba(9, 30, 66, 0.23);
      --color-bg-neutral-subtle: transparent;
      --color-bg-neutral-subtle-hovered: rgba(9, 30, 66, 0.06);
      --color-bg-neutral-bold: var(--_N1000);
      --color-bg-input: var(--_N0);
      --color-bg-input-hovered: var(--_N100);
      --color-bg-disabled: rgba(9, 30, 66, 0.04);
      --color-bg-selected: var(--eq-purple-light);
      --color-bg-selected-hovered: #ebe8fe;
      --color-bg-selected-bold: var(--eq-purple);
      --color-bg-brand-subtlest: var(--eq-purple-light);
      --color-bg-brand-bold: var(--eq-purple);
      --color-bg-danger: var(--_R100);
      --color-bg-danger-bold: var(--_R700);
      --color-bg-warning: var(--_O100);
      --color-bg-warning-bold: var(--_O300);
      --color-bg-success: var(--_L100);
      --color-bg-success-bold: var(--_L700);
      --color-bg-discovery: var(--eq-purple-light);
      --color-bg-discovery-bold: var(--eq-purple);
      --color-bg-information: var(--_B100);
      --color-bg-information-bold: var(--_B700);
      --color-blanket: rgba(9, 30, 66, 0.54);
      --color-blanket-selected: rgba(81, 59, 252, 0.08);
      --color-blanket-danger: rgba(227, 73, 53, 0.08);

      /* ── Elevation: Surface ──────────────────────────────────────── */
      --elevation-surface: var(--_N0);
      --elevation-surface-sunken: var(--eq-cream);
      --elevation-surface-raised: var(--_N0);
      --elevation-surface-raised-hovered: var(--_N200);
      --elevation-surface-overlay: var(--_N0);
      --elevation-surface-overlay-hovered: var(--_N200);

      /* ── Elevation: Shadow ───────────────────────────────────────── */
      --elevation-shadow-raised: 0px 1px 1px rgba(30, 31, 33, 0.25), 0px 0px 1px rgba(30, 31, 33, 0.31);
      --elevation-shadow-overlay: 0px 8px 12px rgba(30, 31, 33, 0.15), 0px 0px 1px rgba(30, 31, 33, 0.31);
      --elevation-shadow-overflow: 0px 0px 8px rgba(30, 31, 33, 0.16), 0px 0px 1px rgba(30, 31, 33, 0.12);

      /* ── Border width ────────────────────────────────────────────── */
      --border-width: 1px;
      --border-width-selected: 2px;
      --border-width-focused: 2px;

      /* ── Radius ──────────────────────────────────────────────────── */
      --radius-xsmall: 2px;
      --radius-small: 4px;
      --radius-medium: 6px;
      --radius-large: 8px;
      --radius-xlarge: 12px;
      --radius-xxlarge: 16px;
      --radius-full: 9999px;

      /* ── Space ───────────────────────────────────────────────────── */
      --space-0: 0px;
      --space-025: 2px;
      --space-050: 4px;
      --space-075: 6px;
      --space-100: 8px;
      --space-150: 12px;
      --space-200: 16px;
      --space-250: 20px;
      --space-300: 24px;
      --space-400: 32px;
      --space-500: 40px;
      --space-600: 48px;
      --space-800: 64px;
      --space-1000: 80px;
      --space-negative-025: -2px;
      --space-negative-050: -4px;
      --space-negative-075: -6px;
      --space-negative-100: -8px;
      --space-negative-150: -12px;
      --space-negative-200: -16px;
      --space-negative-300: -24px;
      --space-negative-400: -32px;

      /* ── Font ────────────────────────────────────────────────────── */
      --font-family-body: 'Inter', ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      --font-family-heading: 'Inter', ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      --font-family-code: ui-monospace, 'SF Mono', 'Cascadia Code', Menlo, Consolas, monospace;
      --font-weight-regular: 400;
      --font-weight-medium: 500;
      --font-weight-semibold: 600;
      --font-weight-bold: 700;
      --font-size-code: 12px;
      --font-size-body-small: 12px;
      --font-size-body: 14px;
      --font-size-body-large: 16px;
      --font-size-heading-xxsmall: 11px;
      --font-size-heading-xsmall: 12px;
      --font-size-heading-small: 14px;
      --font-size-heading-medium: 20px;
      --font-size-heading-large: 24px;
      --font-size-heading-xlarge: 29px;
      --font-size-heading-xxlarge: 35px;

      /* ── Opacity ─────────────────────────────────────────────────── */
      --opacity-disabled: 0.4;
      --opacity-loading: 0.2;

      /* ── Extra font sizes (off-scale) ──────────────────────────── */
      --font-size-body-medium: 13px;
      --font-size-heading-title: 36px;
      --font-size-heading-lane: 17px;

      /* ── Shadow: Component-specific ────────────────────────────── */
      --shadow-neutral-sm: 0 1px 3px rgba(9, 30, 66, 0.15);
      --shadow-neutral-md: 0 2px 8px rgba(9, 30, 66, 0.22);
      --shadow-gold-sm: var(--shadow-neutral-sm);
      --shadow-gold-md: var(--shadow-neutral-md);
      --shadow-purple-sm: var(--shadow-neutral-sm);
      --shadow-purple-md: var(--shadow-neutral-md);
      --shadow-card: 0 1px 3px rgba(0, 0, 0, 0.08);
      --shadow-item: 0 1px 3px rgba(9, 30, 66, 0.12);
      --shadow-item-hover: 0 3px 12px rgba(9, 30, 66, 0.18);
      --shadow-item-selected: 0 2px 8px rgba(9, 30, 66, 0.15);
      --shadow-btn-teal-sm: var(--shadow-neutral-sm);
      --shadow-btn-teal-md: var(--shadow-neutral-md);

      /* ── Overlay colors (white/black alpha) ────────────────────── */
      --color-overlay-dark: rgba(0, 0, 0, 0.3);
      --color-overlay-light-00: rgba(255, 255, 255, 0);
      --color-overlay-light-30: rgba(255, 255, 255, 0.3);
      --color-overlay-light-40: rgba(255, 255, 255, 0.4);
      --color-overlay-light-50: rgba(255, 255, 255, 0.5);
      --color-overlay-light-60: rgba(255, 255, 255, 0.6);
      --color-overlay-light-90: rgba(255, 255, 255, 0.9);

      /* ── Row stripe palette ──────────────────────────────────────── */
      --canvas-row-even: var(--_N100);
      --canvas-row-odd: var(--_N200);
      /* ── EQ Bank brand accent ────────────────────────────────────── */
      --eq-gold: #ffcb31;
      --eq-purple: #513bfc;
      --eq-purple-hover: #4030d9;
      --eq-cream: #fbf8f3;
      --eq-purple-light: #f5f3ff;
      --eq-gold-light: #fff8e6;
      --eq-dark: #333333;
      --eq-text-secondary: #444444;
      --eq-border: #d0d0d0;
      --eq-selection: #3297fd;

      /* ── Initiative palette (500-level primitives, Blue → Magenta) ── */
      --palette-0: var(--_B500);
      /* Blue    */
      --palette-1: var(--_T500);
      /* Teal    */
      --palette-2: var(--_L500);
      /* Green   */
      --palette-3: var(--_Y500);
      /* Yellow  */
      --palette-4: var(--_O500);
      /* Orange  */
      --palette-5: var(--_R500);
      /* Red     */
      --palette-6: var(--_P500);
      /* Purple  */
      --palette-7: var(--_M500);
      /* Magenta */

      /* ── Layout (JS-driven values injected at init) ────────────── */
      --sidebar-width: 180px;
      --header-height: 164px;
      --toolbar-height: 44px;
      --swatch-size: 24px;
      --slide-pad: 48px;
      --item-bar-height: 35px;
      --track-gap: 8px;
      --lane-padding: 16px;
      --title-row-height: 104px;
      --quarter-row-height: 36px;
      --month-row-height: 36px;
      --week-row-height: 36px;
      --ease: cubic-bezier(0.25, 1, 0.5, 1);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: var(--font-family-body);
      font-size: var(--font-size-body);
      color: var(--color-text);
      background: var(--eq-cream);
      overflow: hidden;
      height: 100vh;
      display: flex;
      user-select: none;
      -webkit-user-select: none;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* App container */
    .app-container {
      display: flex;
      flex-direction: column;
      width: 100%;
      height: 100vh;
    }

    /* Control Ribbon */
    .control-ribbon {
      width: 100%;
      background: var(--eq-dark);
      border-bottom: none;
      display: flex;
      flex-direction: row;
      align-items: stretch;
      padding: var(--space-200) var(--space-300);
      gap: var(--space-300);
      flex-shrink: 0;
      overflow-x: auto;
      flex-wrap: wrap;
    }

    .control-section {
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      gap: var(--space-100);
      flex: 1 1 auto;
      min-width: 150px;
    }

    .control-ribbon h3 {
      font-size: var(--font-size-heading-xxsmall);
      font-weight: var(--font-weight-semibold);
      text-transform: uppercase;
      letter-spacing: 0.8px;
      color: rgba(255, 255, 255, 0.5);
      margin: 0;
    }

    .section-content {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: var(--space-100);
      flex: 1;
    }

    .control-ribbon button svg,
    .btn-restart svg {
      vertical-align: -2px;
      flex-shrink: 0;
    }

    .control-ribbon button.btn-icon-only svg {
      vertical-align: 0;
    }

    .control-ribbon button {
      min-width: 80px;
      height: 32px;
      padding: 0 var(--space-200);
      border: var(--border-width) solid rgba(255, 255, 255, 0.15);
      border-radius: var(--radius-medium);
      background: rgba(255, 255, 255, 0.08);
      color: var(--_N0);
      cursor: pointer;
      font-family: var(--font-family-body);
      font-size: var(--font-size-body-medium);
      font-weight: var(--font-weight-medium);
      transition: all 150ms var(--ease);
      white-space: nowrap;
    }

    .control-ribbon button:hover:not(:disabled) {
      border-color: rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.15);
      transform: translateY(-1px);
    }

    .control-ribbon button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      pointer-events: none;
    }

    .control-ribbon button.btn-active {
      background: var(--_N0);
      border-color: var(--_N0);
      color: var(--eq-dark);
    }

    .control-ribbon button.btn-active:hover:not(:disabled) {
      background: var(--_N200);
      border-color: var(--_N0);
      color: var(--eq-dark);
      transform: none;
    }

    .control-ribbon button.btn-primary {
      background: var(--eq-purple);
      border-color: rgba(81, 59, 252, 0.5);
    }

    .control-ribbon button.btn-primary:hover:not(:disabled) {
      background: var(--eq-purple-hover);
      border-color: var(--eq-purple);
    }

    .control-ribbon button.btn-icon-only {
      min-width: 32px;
      width: 32px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .control-section-divider {
      width: var(--border-width);
      background: rgba(255, 255, 255, 0.15);
      margin: 0 var(--space-100);
      align-self: stretch;
    }

    @media (max-width: 900px) {
      .control-section-divider {
        display: none;
      }

      .control-ribbon {
        gap: var(--space-200);
      }

      .control-section {
        padding: var(--space-100);
        background: rgba(255, 255, 255, 0.04);
        border-radius: var(--radius-medium);
      }
    }

    /* Restart button */
    .btn-restart {
      position: fixed;
      bottom: var(--space-200);
      left: var(--space-200);
      padding: 0 var(--space-200);
      height: 32px;
      min-width: 80px;
      border: var(--border-width) solid rgba(0, 0, 0, 0.15);
      border-radius: var(--radius-medium);
      background: rgba(0, 0, 0, 0.06);
      color: var(--eq-dark);
      font-family: var(--font-family-body);
      font-size: var(--font-size-body-medium);
      font-weight: var(--font-weight-medium);
      cursor: pointer;
      opacity: 0.6;
      transition: all 150ms var(--ease);
      z-index: 100;
    }

    .btn-restart:hover {
      opacity: 1;
      border-color: var(--color-bg-danger-bold);
      background: var(--color-bg-danger-bold);
      color: white;
    }

    /* Slide viewport */
    .slide-viewport {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      min-width: 0;
      min-height: 0;
      padding: var(--space-500);
      background: #f0ece5;
    }

    .slide {
      width: 1920px;
      height: 1080px;
      box-sizing: border-box;
      background: var(--eq-cream);
      transform-origin: center center;
      box-shadow: var(--shadow-card);
      border-radius: var(--radius-small);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      flex-shrink: 0;
      padding: var(--space-600);
    }

    /* Main layout */
    .main {
      display: flex;
      flex: 1;
      overflow: hidden;
      border-radius: var(--radius-large);
      border: var(--border-width) solid var(--color-border);
      background: var(--elevation-surface);
      box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.06), inset 0 0 2px rgba(0, 0, 0, 0.04);
    }

    /* Sidebar */
    .sidebar {
      width: var(--sidebar-width);
      min-width: var(--sidebar-width);
      border-right: var(--border-width) solid var(--color-border);
      display: flex;
      flex-direction: column;
      background: var(--elevation-surface);
      z-index: 10;
    }

    .sidebar-header {
      height: var(--header-height);
      border-bottom: var(--border-width) solid var(--color-border);
      display: flex;
      align-items: flex-end;
      padding: 0 var(--space-200) var(--space-100) var(--space-200);
      font-weight: var(--font-weight-semibold);
      font-size: var(--font-size-body);
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--color-text-subtlest);
      background: var(--elevation-surface);
    }

    .sidebar-rows {
      flex: 1;
      overflow: hidden;
    }

    .sidebar-row {
      height: var(--row-height, 56px);
      display: flex;
      align-items: center;
      padding: 0 var(--space-200);
      border-bottom: var(--border-width) solid var(--color-border-disabled);
      cursor: default;
      position: relative;
      transition: background 150ms var(--ease);
    }

    .sidebar-row:hover {
      background: var(--color-bg-neutral-hovered);
    }

    .sidebar-row .lane-name {
      flex: 1;
      font-size: var(--font-size-heading-lane);
      font-weight: var(--font-weight-medium);
      white-space: normal;
      overflow-wrap: break-word;
      cursor: pointer;
      padding: var(--space-050) var(--space-100);
      border-radius: var(--radius-small);
      position: relative;
      border: 1px solid transparent;
      transition: all 150ms var(--ease);
      margin-right: var(--space-100);
    }

    .sidebar-row .lane-name:hover {
      background: transparent;
      border-color: transparent;
    }

    .sidebar-row .lane-name input {
      font-family: inherit;
      font-size: inherit;
      font-weight: inherit;
      border: none;
      border-radius: 0;
      outline: none;
      padding: 0;
      margin: 0;
      width: 100%;
      background: transparent;
      color: inherit;
    }

    .sidebar-row .lane-actions {
      display: none;
      gap: var(--space-025);
    }

    .sidebar-row:hover .lane-actions {
      display: flex;
    }

    .lane-actions button {
      width: 22px;
      height: 22px;
      border: none;
      background: none;
      cursor: pointer;
      border-radius: var(--radius-small);
      font-size: var(--font-size-body);
      color: var(--color-text-subtle);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .lane-actions button:hover {
      background: var(--elevation-surface-sunken);
      color: var(--color-icon-danger);
    }

    /* Drag-over indicator for sidebar rows */
    .sidebar-row.drag-over-above {
      box-shadow: inset 0 2px 0 var(--_N700);
    }

    .sidebar-row.drag-over-below {
      box-shadow: inset 0 -2px 0 var(--_N700);
    }

    /* Timeline area */
    .timeline-area {
      flex: 1;
      overflow: hidden;
      position: relative;
      display: flex;
      flex-direction: column;
    }

    .timeline-header {
      height: var(--header-height);
      flex-shrink: 0;
      position: sticky;
      top: 0;
      z-index: 5;
      background: var(--elevation-surface);
      border-bottom: var(--border-width) solid var(--color-border);
      display: flex;
      flex-direction: column;
      width: 100%;
    }

    .timeline-header-row {
      display: flex;
      width: 100%;
    }

    .timeline-title-row {
      background: var(--elevation-surface);
      padding: 0 var(--space-200);
      display: flex;
      align-items: center;
    }

    .slide-logo {
      margin-left: auto;
      padding: var(--space-200) 0;
      height: 100%;
      width: auto;
      object-fit: contain;
      pointer-events: none;
      flex-shrink: 0;
      box-sizing: border-box;
    }

    .timeline-title {
      font-size: var(--font-size-heading-title);
      font-weight: var(--font-weight-semibold);
      color: var(--color-text);
      cursor: pointer;
      padding: var(--space-100) var(--space-200);
      border-radius: var(--radius-small);
      letter-spacing: -0.01em;
      position: relative;
      display: inline-block;
      border: 1px solid transparent;
      background: transparent;
      transition: all 150ms var(--ease);
      margin-right: var(--space-300);
    }

    .timeline-title:hover {
      background: transparent;
      border-color: transparent;
    }

    .timeline-title input {
      font-family: inherit;
      font-size: inherit;
      font-weight: inherit;
      border: none;
      border-radius: 0;
      outline: none;
      padding: 0;
      margin: 0;
      background: transparent;
      color: inherit;
      width: 100%;
      min-width: 200px;
    }

    .timeline-col-header {
      border: var(--border-width) solid var(--color-border-disabled);
      margin-right: calc(-1 * var(--border-width));
      flex-grow: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: var(--font-size-heading-lane);
      font-weight: var(--font-weight-medium);
      color: var(--color-text);
      box-sizing: border-box;
    }

    .timeline-grid {
      position: relative;
      flex: 1;
      overflow: hidden;
    }

    .timeline-grid-row {
      height: var(--row-height, 56px);
      border-bottom: var(--border-width) solid var(--color-border-disabled);
      position: relative;
    }

    .gridline {
      position: absolute;
      top: 0;
      bottom: 0;
      width: var(--border-width);
      background: var(--color-border-disabled);
      pointer-events: none;
      z-index: 0;
    }

    .track-separator {
      position: absolute;
      left: 0;
      right: 0;
      height: 1px;
      background: var(--color-border-disabled);
      pointer-events: none;
      opacity: 0.5;
      z-index: 1;
    }

    /* Item bars */
    .item-bar {
      position: absolute;
      height: var(--item-bar-height, 35px);
      border-radius: var(--radius-medium);
      cursor: pointer;
      display: flex;
      align-items: center;
      padding: 0 var(--space-100);
      font-size: var(--font-size-heading-lane);
      font-weight: var(--font-weight-medium);
      color: var(--color-text-inverse);
      z-index: 3;
      min-width: var(--space-150);
      box-shadow: var(--shadow-item);
      pointer-events: auto;
      transition: box-shadow 200ms var(--ease), transform 200ms var(--ease), opacity 150ms var(--ease);
    }

    .item-bar:hover {
      box-shadow: var(--shadow-item-hover);
      transform: translateY(-1px);
      z-index: 4;
    }

    .item-bar-text {
      pointer-events: auto;
      flex: 1;
      cursor: pointer;
    }


    .item-bar input {
      font-family: inherit;
      font-size: inherit;
      font-weight: inherit;
      color: inherit;
      background: transparent;
      border: none;
      border-radius: 0;
      outline: none;
      padding: 0 var(--space-050);
      margin: 0 calc(-1 * var(--space-050));
      width: calc(100% + var(--space-100));
      caret-color: white;
    }

    .item-bar:hover,
    .item-bar.selected {
      box-shadow: 0 0 0 2px var(--bar-color), 0 0 16px var(--bar-color), var(--shadow-item-selected);
    }

    .item-bar.dragging {
      opacity: 0.9;
      cursor: grabbing;
      z-index: 100;
      box-shadow: var(--shadow-card);
      transform: translateY(-2px);
    }

    .item-bar .resize-handle {
      position: absolute;
      top: 0;
      bottom: 0;
      width: var(--space-100);
      cursor: ew-resize;
      z-index: 4;
      pointer-events: auto;
      transition: background 150ms var(--ease);
    }

    .item-bar .resize-handle.left {
      left: 0;
      border-radius: var(--radius-medium) 0 0 var(--radius-medium);
    }

    .item-bar .resize-handle.right {
      right: 0;
      border-radius: 0 var(--radius-medium) var(--radius-medium) 0;
    }

    .item-bar:hover .resize-handle {
      background: rgba(255, 255, 255, 0.2);
    }

    .item-bar .resize-handle:hover {
      background: rgba(255, 255, 255, 0.4);
    }

    /* Ghost bar (drag-create) */
    .ghost-bar {
      position: absolute;
      height: 28px;
      top: 50%;
      transform: translateY(-50%);
      border-radius: var(--radius-medium);
      background: var(--_N600);
      opacity: var(--opacity-loading);
      pointer-events: none;
      z-index: 5;
    }


    /* Color swatches */
    .color-swatches {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: var(--space-100);
    }

    .color-swatch {
      width: var(--swatch-size);
      height: var(--swatch-size);
      border-radius: var(--radius-full);
      cursor: pointer;
      border: var(--border-width-selected) solid transparent;
      box-shadow: var(--elevation-shadow-raised);
      transition: all 150ms var(--ease);
      flex-shrink: 0;
    }

    .color-swatch:hover {
      transform: scale(1.15);
      box-shadow: var(--elevation-shadow-overlay);
    }

    .color-swatch.selected {
      box-shadow: 0 0 0 2px var(--elevation-surface), 0 0 0 4px var(--_N700);
    }

    .color-swatch-info {
      font-size: var(--font-size-body-small);
      color: rgba(255, 255, 255, 0.5);
      min-height: 0;
    }

    .color-swatch-info:empty {
      display: none;
    }

    /* Legend */
    .timeline-legend {
      position: absolute;
      bottom: var(--space-300);
      right: var(--space-300);
      left: auto;
      display: flex;
      flex-direction: column;
      gap: var(--space-100);
      z-index: 10;
    }

    .timeline-legend.legend-align-left {
      right: auto;
      left: var(--space-300);
    }

    .timeline-legend.legend-align-center {
      right: auto;
      left: 50%;
      transform: translateX(-50%);
    }

    .timeline-legend.legend-align-right {
      left: auto;
      right: var(--space-300);
    }

    .timeline-legend.legend-horizontal {
      flex-direction: row;
      flex-wrap: wrap;
      min-width: 0;
    }

.legend-item {
      display: flex;
      align-items: center;
      gap: var(--space-100);
    }

    .legend-color {
      width: 16px;
      height: 16px;
      border-radius: var(--radius-small);
      flex-shrink: 0;
    }

    .legend-label {
      font-size: var(--font-size-heading-lane);
      font-weight: var(--font-weight-medium);
      color: var(--color-text);
      cursor: pointer;
      flex: 1;
      padding: var(--space-050) var(--space-100);
      border-radius: var(--radius-small);
      border: 1px solid transparent;
      transition: all 150ms var(--ease);
      position: relative;
    }

    .legend-label:hover {
      background: transparent;
      border-color: transparent;
    }

    .legend-label input {
      font-family: inherit;
      font-size: inherit;
      font-weight: inherit;
      color: inherit;
      background: transparent;
      border: none;
      border-radius: 0;
      outline: none;
      padding: 0;
      margin: 0;
      min-width: 2ch;
    }

    /* Empty state */
    .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      flex: 1;
      color: var(--color-text-subtle);
      gap: var(--space-200);
    }

    .empty-state p {
      font-family: var(--font-family-body);
      font-size: var(--font-size-body);
      font-weight: var(--font-weight-medium);
    }

    .empty-state button {
      font-family: var(--font-family-body);
      font-size: var(--font-size-body);
      font-weight: var(--font-weight-semibold);
      height: 38px;
      padding: 0 var(--space-300);
      border: 1px solid var(--eq-purple);
      border-radius: var(--radius-medium);
      background: var(--eq-purple);
      color: var(--_N0);
      cursor: pointer;
      box-shadow: var(--shadow-purple-sm);
      transition: all 150ms var(--ease);
    }

    .empty-state button:hover {
      background: var(--eq-purple-hover);
      border-color: var(--eq-purple-hover);
      box-shadow: var(--shadow-purple-md);
      transform: translateY(-1px);
    }


    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: var(--space-100);
      height: var(--space-100);
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--_N300);
      border-radius: var(--radius-small);
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--_N500);
    }

    /* Drag tooltip */
    .drag-tooltip {
      position: fixed;
      background: var(--color-bg-neutral-bold);
      color: var(--color-text-inverse);
      padding: var(--space-100) var(--space-200);
      border-radius: var(--radius-large);
      font-family: var(--font-family-body);
      font-size: var(--font-size-body);
      font-weight: var(--font-weight-medium);
      pointer-events: none;
      z-index: 10000;
      white-space: nowrap;
      box-shadow: var(--elevation-shadow-overlay);
    }

    /* Confirm dialog */
    .confirm-overlay {
      position: fixed;
      inset: 0;
      z-index: 2000;
      background: var(--color-blanket);
      backdrop-filter: blur(2px);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .confirm-box {
      background: var(--elevation-surface-overlay);
      border-radius: var(--radius-xlarge);
      padding: var(--space-300);
      width: 320px;
      box-shadow: var(--elevation-shadow-overlay);
    }

    .confirm-box p {
      font-size: var(--font-size-body);
      margin-bottom: var(--space-200);
      line-height: 1.5;
    }

    .confirm-box .confirm-actions {
      display: flex;
      gap: var(--space-100);
      justify-content: flex-end;
    }

    .confirm-box button {
      height: 36px;
      padding: 0 var(--space-200);
      border: var(--border-width) solid var(--color-border);
      border-radius: var(--radius-large);
      font-family: var(--font-family-body);
      font-size: var(--font-size-body);
      cursor: pointer;
      background: var(--elevation-surface);
      transition: all 150ms var(--ease);
    }

    .confirm-box button:hover {
      background: var(--color-bg-neutral-hovered);
    }

    .confirm-box .btn-danger {
      background: var(--color-bg-danger-bold);
      color: var(--color-text-inverse);
      border-color: var(--color-bg-danger-bold);
    }

    .confirm-box .btn-danger:hover {
      filter: brightness(0.9);
    }

    /* Sidebar resize handle */
    .sidebar-resize-handle {
      position: absolute;
      top: 0;
      right: -2px;
      width: 4px;
      height: 100%;
      cursor: col-resize;
      z-index: 11;
      transition: background 150ms var(--ease);
    }

    .sidebar-resize-handle:hover,
    .sidebar-resize-handle.active {
      background: var(--eq-purple);
    }

    .sidebar {
      position: relative;
    }

    /* Context menu */
    .ctx-menu {
      position: fixed;
      background: var(--elevation-surface-overlay);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-medium);
      box-shadow: var(--elevation-shadow-overlay);
      z-index: 3000;
      min-width: 148px;
      padding: var(--space-050) 0;
      animation: ctx-enter 120ms var(--ease) forwards;
    }

    .ctx-menu.ctx-exit {
      animation: ctx-exit 100ms var(--ease) forwards;
    }

    @keyframes ctx-enter {
      from { opacity: 0; transform: scale(0.96) translateY(-4px); }
      to   { opacity: 1; transform: scale(1) translateY(0); }
    }

    @keyframes ctx-exit {
      from { opacity: 1; }
      to   { opacity: 0; }
    }

    .ctx-menu-item {
      display: flex;
      align-items: center;
      width: 100%;
      padding: var(--space-100) var(--space-150);
      font-size: var(--font-size-body);
      font-family: var(--font-family-body);
      font-weight: var(--font-weight-regular);
      color: var(--color-text);
      background: none;
      border: none;
      cursor: pointer;
      text-align: left;
      transition: background 80ms;
      box-sizing: border-box;
    }

    .ctx-menu-item:hover {
      background: var(--color-bg-neutral-subtle-hovered);
    }

    .ctx-menu-item.ctx-danger {
      color: var(--color-text-danger);
    }

    .ctx-menu-item.ctx-danger:hover {
      background: var(--color-bg-danger);
    }

    .ctx-menu-item.ctx-disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .ctx-menu-item.ctx-disabled:hover {
      background: transparent;
    }

    .ctx-menu-separator {
      height: 1px;
      background: var(--color-border);
      margin: var(--space-050) 0;
    }

    .ctx-menu-colors {
      display: flex;
      align-items: center;
      gap: 5px;
      padding: var(--space-075) var(--space-150);
    }

    .ctx-menu-swatch {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid transparent;
      box-sizing: border-box;
      transition: transform 80ms, border-color 80ms;
      flex-shrink: 0;
    }

    .ctx-menu-swatch:hover {
      transform: scale(1.2);
    }

    .ctx-menu-swatch.selected {
      border-color: var(--color-text);
    }


    /* Bar label — auto-positioned, no drag */
    .item-bar-label {
      position: absolute;
      white-space: nowrap;
      pointer-events: auto;
      cursor: default;
      z-index: 5;
      font-size: var(--font-size-heading-lane);
      font-weight: var(--font-weight-medium);
      color: var(--color-text-inverse);
      padding: 0;
      border-radius: 0;
      user-select: none;
      -webkit-user-select: none;
    }

    .item-bar-label.label-overflow {
      background: none !important;
      color: var(--color-text);
    }

    .item-bar-label.label-overflow input {
      caret-color: var(--color-text);
    }

    .item-bar-label input {
      font-family: inherit;
      font-size: inherit;
      font-weight: inherit;
      color: inherit;
      background: transparent;
      border: none;
      border-radius: 0;
      outline: none;
      padding: 0;
      margin: 0;
      width: 100%;
      caret-color: white;
    }

    /* Week row header */
    .timeline-week-header {
      display: flex;
      width: 100%;
    }

    .timeline-week-header .timeline-col-header {
      color: var(--color-text-subtlest);
      font-weight: var(--font-weight-regular);
    }

    /* Timeline length slider */
    .length-slider-wrapper {
      display: flex;
      flex-direction: column;
      gap: var(--space-100);
      min-width: 140px;
    }

    .length-slider-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .length-slider-header .length-display {
      color: var(--_N0);
      font-size: var(--font-size-body-medium);
      font-weight: var(--font-weight-medium);
      font-variant-numeric: tabular-nums;
    }

    #length-slider {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 4px;
      border-radius: 2px;
      background: rgba(255, 255, 255, 0.2);
      outline: none;
      cursor: pointer;
    }

    #length-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--_N0);
      cursor: pointer;
      transition: transform 100ms var(--ease);
    }

    #length-slider::-moz-range-thumb {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--_N0);
      border: none;
      cursor: pointer;
    }

    #length-slider:hover::-webkit-slider-thumb {
      transform: scale(1.2);
    }
  </style>
</head>

<body>

  <div class="app-container">
    <div class="control-ribbon" id="control-sidebar">
      <div class="control-section">
        <h3>Structure</h3>
        <div class="section-content">
          <button id="btn-add-swimlane" class="btn-primary"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg> Add Group</button>
          <button id="btn-add-item" class="btn-primary"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg> Add Initiative</button>
        </div>
      </div>

      <div class="control-section-divider"></div>

      <div class="control-section">
        <h3>Length</h3>
        <div class="section-content">
          <div class="length-slider-wrapper">
            <div class="length-slider-header">
              <span class="length-display" id="length-display">12 mo</span>
            </div>
            <input type="range" id="length-slider" min="1" max="12" value="12">
          </div>
        </div>
      </div>

      <div class="control-section-divider"></div>

      <div class="control-section">
        <h3>History</h3>
        <div class="section-content">
          <button id="btn-undo" class="btn-icon-only" disabled title="Undo (Ctrl+Z)"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/></svg></button>
          <button id="btn-redo" class="btn-icon-only" disabled title="Redo (Ctrl+Y)"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"/><path d="M20.49 15a9 9 0 1 1-2.13-9.36L23 10"/></svg></button>
        </div>
      </div>

      <div class="control-section-divider"></div>

      <div class="control-section">
        <h3>Legend</h3>
        <div class="section-content">
          <button id="btn-legend-vertical">Vertical</button>
          <button id="btn-legend-horizontal">Horizontal</button>
          <button id="btn-legend-left" class="btn-icon-only" title="Align left"><svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.75" stroke-linecap="round"><line x1="1" y1="3" x2="13" y2="3"/><line x1="1" y1="7" x2="9" y2="7"/><line x1="1" y1="11" x2="13" y2="11"/></svg></button>
          <button id="btn-legend-center" class="btn-icon-only" title="Align center"><svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.75" stroke-linecap="round"><line x1="1" y1="3" x2="13" y2="3"/><line x1="3" y1="7" x2="11" y2="7"/><line x1="1" y1="11" x2="13" y2="11"/></svg></button>
          <button id="btn-legend-right" class="btn-icon-only" title="Align right"><svg width="14" height="14" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.75" stroke-linecap="round"><line x1="1" y1="3" x2="13" y2="3"/><line x1="5" y1="7" x2="13" y2="7"/><line x1="1" y1="11" x2="13" y2="11"/></svg></button>
        </div>
      </div>

      <div class="control-section-divider"></div>

      <div class="control-section">
        <h3>Export</h3>
        <div class="section-content">
          <button id="btn-export"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg> PNG</button>
          <button id="btn-export-csv"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/></svg> CSV</button>
        </div>
      </div>

    </div>

    <div class="slide-viewport">
      <div class="slide" id="slide">
        <div id="app"></div>
      </div>
    </div>

    <button class="btn-restart" id="btn-reset"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg> Restart</button>
  </div>

  <script>
    (function () {
      "use strict";

      const PALETTE = Array.from({ length: 8 }, (_, i) => `var(--palette-${i})`);
      const STORAGE_KEY = 'timeline_tmpl_v1';
      const MONTH_NAMES = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      const MONTH_NAMES_FULL = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

      // Layout and behavior constants (avoid magic numbers scattered in code)
      const MS_PER_DAY = 86400000;
      const MIN_BAR_WIDTH = 12;
      const DRAG_THRESHOLD = 5;
      const LABEL_PAD_H = 12;
      const DEFAULT_SIDEBAR_W = 180;
      const AUTOFOCUS_DELAY_MS = 30;
      const SAVE_DEBOUNCE_MS = 500;
      const MAX_HISTORY = 50;
      const FY_START_MONTH = 9; // October (0-indexed)

      // Interpolate from eq-gold-light (#fff8e6) to eq-gold (#ffcb31), t in [0,1]
      function goldRamp(t) {
        const r = Math.round(255 + (255 - 255) * t);
        const g = Math.round(248 + (203 - 248) * t);
        const b = Math.round(230 + (49 - 230) * t);
        return `rgb(${r},${g},${b})`;
      }

      // ---- State ----
      function defaultState() {
        const today = new Date();
        const { start, end } = fiscalQuarterRange(today);
        return {
          timeline: {
            startDate: fmt(start),
            endDate: fmt(end),
            zoomLevel: 1,
            title: 'New Timeline',
            monthCount: 12,
            sidebarWidth: DEFAULT_SIDEBAR_W,
            legendOrientation: 'vertical',
            legendAlign: 'right'
          },
          swimlanes: [],
          items: [],
          legendLabels: {} // Map of color -> label
        };
      }

      let STATE = defaultState();
      let stateHistory = [JSON.parse(JSON.stringify(STATE))];
      let historyIndex = 0;

      function pushHistory(newState) {
        if (historyIndex < stateHistory.length - 1) {
          stateHistory = stateHistory.slice(0, historyIndex + 1);
        }
        stateHistory.push(JSON.parse(JSON.stringify(newState)));
        if (stateHistory.length > MAX_HISTORY) {
          stateHistory.shift();
        } else {
          historyIndex++;
        }
        updateUndoRedoUI();
      }

      function undo() {
        if (historyIndex > 0) {
          historyIndex--;
          STATE = JSON.parse(JSON.stringify(stateHistory[historyIndex]));
          assignTracks();
          saveState();
          render();
          updateUndoRedoUI();
        }
      }

      function redo() {
        if (historyIndex < stateHistory.length - 1) {
          historyIndex++;
          STATE = JSON.parse(JSON.stringify(stateHistory[historyIndex]));
          assignTracks();
          saveState();
          render();
          updateUndoRedoUI();
        }
      }

      function updateUndoRedoUI() {
        const btnUndo = document.getElementById('btn-undo');
        const btnRedo = document.getElementById('btn-redo');
        if (btnUndo) btnUndo.disabled = historyIndex <= 0;
        if (btnRedo) btnRedo.disabled = historyIndex >= stateHistory.length - 1;
      }

      // Shared fiscal calendar calculation for a given date.
      // Returns fiscalMonth (0=Oct..11=Sep), fiscalQuarter (0-based), fyYear.
      function getFiscalInfo(date) {
        const month = date.getMonth();
        const year = date.getFullYear();
        const fiscalMonth = (month - FY_START_MONTH + 12) % 12;
        const fiscalQuarter = Math.floor(fiscalMonth / 3);
        const fyYear = month >= FY_START_MONTH ? year : year - 1;
        return { fiscalMonth, fiscalQuarter, fyYear };
      }

      // Returns the start of the current fiscal quarter and 4 quarters later.
      function fiscalQuarterRange(today) {
        const { fiscalQuarter, fyYear } = getFiscalInfo(today);
        const qCalMonth = (FY_START_MONTH + fiscalQuarter * 3) % 12;
        const qYear = qCalMonth >= FY_START_MONTH ? fyYear : fyYear + 1;
        const start = new Date(qYear, qCalMonth, 1);
        const end = new Date(qYear + 1, qCalMonth, 1);
        return { start, end };
      }

      function fmt(d) {
        const y = d.getFullYear();
        const m = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        return `${y}-${m}-${day}`;
      }

      function parseDate(s) {
        if (!s || typeof s !== 'string') return new Date();
        const [y, m, d] = s.split('-').map(Number);
        if (isNaN(y) || isNaN(m) || isNaN(d)) return new Date();
        return new Date(y, m - 1, d);
      }

      function uid() {
        if (crypto.randomUUID) return crypto.randomUUID();
        return Date.now().toString(36) + Math.random().toString(36).slice(2, 10);
      }

      // ---- Persistence ----
      let saveTimer = null;

      function saveState() {
        clearTimeout(saveTimer);
        saveTimer = setTimeout(() => {
          try { localStorage.setItem(STORAGE_KEY, JSON.stringify(STATE)); } catch (e) {
            console.error('Save failed:', e);
            showInfo('Could not save. Storage may be full.');
          }
        }, SAVE_DEBOUNCE_MS);
      }

      const COLOR_MIGRATION = {
        '#4f6df5': '#5b8dbf', '#e5484d': '#d4736c', '#30a46c': '#5ea87a', '#e38627': '#d4964a',
        '#8b5cf6': '#9179c2', '#0ea5e9': '#5ea5b8', '#ec4899': '#c97ba0', '#6d6e75': '#8a8580'
      };

      function loadState() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (raw) {
            const parsed = JSON.parse(raw);
            if (parsed && parsed.timeline) STATE = parsed;
          }
        } catch (e) { console.error('Load failed:', e); }
        // Migrate old palette colors and add track property
        if (STATE.items) {
          STATE.items.forEach(item => {
            const mapped = COLOR_MIGRATION[item.color];
            if (mapped) item.color = mapped;
            if (item.track === undefined) item.track = 0;
          });
        }
        if (STATE.swimlanes) {
          STATE.swimlanes.forEach(lane => {
            if (lane.minRows === undefined) lane.minRows = 1;
          });
        }
        if (!STATE.legendLabels) {
          STATE.legendLabels = {};
        }
        if (!STATE.timeline.monthCount) {
          STATE.timeline.monthCount = 12;
        }
        if (!STATE.timeline.sidebarWidth) {
          STATE.timeline.sidebarWidth = DEFAULT_SIDEBAR_W;
        }
        if (!STATE.timeline.legendOrientation) {
          STATE.timeline.legendOrientation = 'vertical';
        }
        if (!STATE.timeline.legendAlign) {
          STATE.timeline.legendAlign = 'right';
        }
        // Update timeline dates based on monthCount
        updateTimelineDates();
        // Assign tracks after loading
        assignTracks();

        // Reset history to the loaded state
        stateHistory = [JSON.parse(JSON.stringify(STATE))];
        historyIndex = 0;
        updateUndoRedoUI();
      }

      function updateTimelineDates() {
        const mc = STATE.timeline.monthCount || 12;
        const start = parseDate(STATE.timeline.startDate);
        const end = new Date(start.getFullYear(), start.getMonth() + mc, start.getDate());
        STATE.timeline.endDate = fmt(end);
      }

      function setState(fn, skipHistory = false) {
        fn(STATE);
        assignTracks();
        saveState();
        if (!skipHistory) {
          pushHistory(STATE);
        }
        render();
      }

      // ---- Track assignment ----
      function assignTracks() {
        // Preserve user-set track positions. Only push items DOWN when there is
        // an actual collision on their current track — never pack items upward.
        STATE.swimlanes.forEach(lane => {
          const laneItems = STATE.items.filter(it => it.swimlaneId === lane.id);
          if (laneItems.length === 0) return;

          // Sort by intended track first, then by start date within each track.
          // This ensures earlier-placed items on a track claim it before later ones.
          laneItems.sort((a, b) => {
            if (a.track !== b.track) return a.track - b.track;
            return parseDate(a.startDate).getTime() - parseDate(b.startDate).getTime();
          });

          // trackEnds[t] = latest end date of items already placed on track t
          const trackEnds = {};

          laneItems.forEach(item => {
            const itemStart = parseDate(item.startDate);
            const itemEnd   = parseDate(item.endDate);
            let t = item.track;

            // Push down only if there is a real collision on track t
            while (trackEnds[t] && itemStart < trackEnds[t]) {
              t++;
            }

            item.track = t;
            if (!trackEnds[t] || itemEnd > trackEnds[t]) {
              trackEnds[t] = itemEnd;
            }
          });
        });
      }

      // ---- Date axis helpers ----
      function daysBetween(a, b) {
        const utcA = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());
        const utcB = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());
        return Math.round((utcB - utcA) / MS_PER_DAY);
      }

      function addDays(d, n) {
        const r = new Date(d);
        r.setDate(r.getDate() + n);
        return r;
      }

      function snapToMonday(date) {
        const d = new Date(date);
        const day = d.getDay();
        const diff = (day === 0 ? -6 : 1 - day); // Sunday = 0, Monday = 1
        d.setDate(d.getDate() + diff);
        d.setHours(0, 0, 0, 0);
        return d;
      }

      function columnWidthPct(col, tlStart, totalDays) {
        const days = daysBetween(tlStart, col.end) - daysBetween(tlStart, col.start);
        return (days / totalDays) * 100;
      }

      function formatDateForTooltip(date) {
        return `${MONTH_NAMES[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;
      }

      function getQuarters(start, end) {
        const quarters = [];
        let cur = new Date(start);
        while (cur < end) {
          const fi = getFiscalInfo(cur);
          const nextQIdx = fi.fiscalQuarter + 1;
          const nextCalMonth = (FY_START_MONTH + nextQIdx * 3) % 12;
          const nextFyYear = nextQIdx >= 4 ? fi.fyYear + 1 : fi.fyYear;
          const nextYear = nextCalMonth < FY_START_MONTH ? nextFyYear + 1 : nextFyYear;
          const next = new Date(nextYear, nextCalMonth, 1);
          quarters.push({
            start: new Date(cur),
            end: next > end ? new Date(end) : next,
            label: `Q${fi.fiscalQuarter + 1} FY${String(fi.fyYear + 1).slice(2)}`
          });
          cur = next;
        }
        return quarters;
      }

      function getColumns(start, end, granularity) {
        const generators = { day: getDays, week: getWeeks, month: getMonths, quarter: getQuarters };
        return generators[granularity](start, end);
      }

      function getMonths(start, end) {
        const months = [];
        let cur = new Date(start.getFullYear(), start.getMonth(), 1);
        while (cur < end) {
          const next = new Date(cur.getFullYear(), cur.getMonth() + 1, 1);
          months.push({
            start: new Date(cur),
            end: next > end ? new Date(end) : next,
            label: MONTH_NAMES[cur.getMonth()]
          });
          cur = next;
        }
        return months;
      }

      function getWeeks(start, end) {
        const weeks = [];
        let cur = new Date(start);
        cur = snapToMonday(cur);

        let weekNum = 1;
        while (cur < end) {
          const next = addDays(cur, 7);
          weeks.push({
            start: new Date(cur),
            end: next > end ? new Date(end) : next,
            label: `W${weekNum}`
          });
          cur = next;
          weekNum++;
        }
        return weeks;
      }

      function getDays(start, end) {
        const days = [];
        let cur = new Date(start);
        while (cur < end) {
          const next = addDays(cur, 1);
          days.push({
            start: new Date(cur),
            end: next > end ? new Date(end) : next,
            label: String(cur.getDate())
          });
          cur = next;
        }
        return days;
      }

      const SLIDE_W = 1920, SLIDE_H = 1080;

      // Read layout constants from CSS custom properties (single source of truth)
      function cssVar(name) {
        return parseInt(getComputedStyle(document.documentElement).getPropertyValue(name), 10);
      }
      const SLIDE_PAD = cssVar('--slide-pad');
      const CONTENT_W = SLIDE_W - SLIDE_PAD * 2;
      const CONTENT_H = SLIDE_H - SLIDE_PAD * 2;
      const TITLE_ROW_H = cssVar('--title-row-height');
      const QUARTER_ROW_H = cssVar('--quarter-row-height');
      const MONTH_ROW_H = cssVar('--month-row-height');
      const WEEK_ROW_H = cssVar('--week-row-height');
      const ITEM_BAR_H = cssVar('--item-bar-height');
      const TRACK_GAP = cssVar('--track-gap');
      const LANE_PADDING = cssVar('--lane-padding');

      function getSidebarWidth() {
        return STATE.timeline.sidebarWidth || DEFAULT_SIDEBAR_W;
      }

      function getTimelineWidth() {
        return CONTENT_W - getSidebarWidth();
      }

      function getDisplayConfig(monthCount) {
        return {
          showQuarterRow: monthCount >= 4,
          showSubMonthRow: monthCount <= 3,
          subMonthMode: monthCount <= 1 ? 'day' : 'week',
          topGranularity: monthCount <= 2 ? 'month' : 'quarter',
          useFullMonthNames: monthCount < 6,
          monthColorMode: monthCount < 4 ? 'gradient' : 'alternating',
        };
      }

      function getHeaderHeight() {
        const cfg = getDisplayConfig(STATE.timeline.monthCount || 12);
        let h = TITLE_ROW_H + MONTH_ROW_H;
        if (cfg.showQuarterRow) h += QUARTER_ROW_H;
        if (cfg.showSubMonthRow) h += WEEK_ROW_H;
        return h;
      }

      function getGridHeight() {
        return CONTENT_H - getHeaderHeight();
      }

      function getTrackCount(laneId) {
        const lane = STATE.swimlanes.find(l => l.id === laneId);
        const minRows = (lane && lane.minRows) ? lane.minRows : 1;
        const laneItems = STATE.items.filter(it => it.swimlaneId === laneId);
        if (laneItems.length === 0) return minRows;
        const itemMax = Math.max(...laneItems.map(it => it.track)) + 1;
        return Math.max(itemMax, minRows);
      }

      function getLaneHeight(laneId) {
        const trackCount = getTrackCount(laneId);
        return trackCount * ITEM_BAR_H + (trackCount - 1) * TRACK_GAP + LANE_PADDING * 2;
      }

      function getLaneHeights() {
        const raw = STATE.swimlanes.map(lane => getLaneHeight(lane.id));
        const total = raw.reduce((sum, h) => sum + h, 0);
        if (total <= getGridHeight()) return raw;
        // Scale proportionally to fit within available grid height
        const scale = getGridHeight() / total;
        return raw.map(h => Math.floor(h * scale));
      }

      function getTotalGridHeight() {
        const heights = getLaneHeights();
        return heights.reduce((sum, h) => sum + h, 0);
      }

      function getRowHeight() {
        return getGridHeight() / Math.max(STATE.swimlanes.length, 1);
      }

      function getColWidth(cols) {
        return getTimelineWidth() / Math.max(cols.length, 1);
      }

      // Measure rendered width of a label string using canvas (matches label CSS font)
      let _measureCanvas = null;
      function measureLabelText(text) {
        if (!_measureCanvas) {
          _measureCanvas = document.createElement('canvas');
        }
        const ctx = _measureCanvas.getContext('2d');
        ctx.font = '500 17px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
        return ctx.measureText(text).width;
      }

      function getItemBarHeight() {
        const rh = getRowHeight();
        return Math.max(10, Math.min(rh * 0.5, 35));
      }

      function getSlideScale() {
        const slide = document.getElementById('slide');
        if (!slide) return 1;
        const rect = slide.getBoundingClientRect();
        return Math.max(rect.width / SLIDE_W, 0.01);
      }

      function updateSlideScale() {
        const slide = document.getElementById('slide');
        const viewport = document.querySelector('.slide-viewport');
        if (!slide || !viewport) return;

        // Account for viewport padding (40px on each side = 80px total)
        const padding = 80;
        const availW = viewport.clientWidth - padding;
        const availH = viewport.clientHeight - padding;

        // Calculate scale to fit while maintaining aspect ratio
        const scaleX = availW / SLIDE_W;
        const scaleY = availH / SLIDE_H;
        const scale = Math.min(scaleX, scaleY, 1);

        slide.style.transform = `scale(${scale})`;
      }

      // Position helpers
      function dateToX(date, tlStart, totalDays, totalWidth) {
        const d = daysBetween(tlStart, date);
        return (d / totalDays) * totalWidth;
      }

      function xToDate(x, tlStart, totalDays, totalWidth) {
        if (totalWidth === 0) return new Date(tlStart);
        const frac = x / totalWidth;
        const days = Math.round(frac * totalDays);
        return addDays(tlStart, days);
      }

      // ---- Selection state ----
      let selectedItemId = null;

      // ---- Drag state ----
      let dragState = null;
      // types: 'create', 'move', 'resize-left', 'resize-right', 'reorder-lane'
      let dragTooltip = null; // DOM element for showing date during drag

      function showDragTooltip(text, x, y) {
        if (!dragTooltip) {
          dragTooltip = document.createElement('div');
          dragTooltip.className = 'drag-tooltip';
          document.body.appendChild(dragTooltip);
        }
        dragTooltip.textContent = text;
        dragTooltip.style.left = (x + 15) + 'px';
        dragTooltip.style.top = (y - 30) + 'px';
        dragTooltip.style.display = 'block';
      }

      function hideDragTooltip() {
        if (dragTooltip) {
          dragTooltip.remove();
          dragTooltip = null;
        }
      }

      // ---- Render helpers ----
      function buildEmptyState() {
        const empty = document.createElement('div');
        empty.className = 'empty-state';
        empty.innerHTML = '<p>Add a group to get started</p>';
        const btn = document.createElement('button');
        btn.textContent = '+ Add Group';
        btn.onclick = addSwimlane;
        empty.appendChild(btn);
        return empty;
      }

      function buildSidebarRow(lane, height) {
        const row = document.createElement('div');
        row.className = 'sidebar-row';
        row.dataset.laneId = lane.id;
        row.draggable = true;
        row.style.height = height + 'px';

        row.addEventListener('dragstart', (e) => {
          e.dataTransfer.setData('text/plain', lane.id);
          e.dataTransfer.effectAllowed = 'move';
          row.style.opacity = '0.5';
        });
        row.addEventListener('dragend', () => { row.style.opacity = ''; });
        row.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          const rect = row.getBoundingClientRect();
          const mid = rect.top + rect.height / 2;
          row.classList.remove('drag-over-above', 'drag-over-below');
          if (e.clientY < mid) row.classList.add('drag-over-above');
          else row.classList.add('drag-over-below');
        });
        row.addEventListener('dragleave', () => {
          row.classList.remove('drag-over-above', 'drag-over-below');
        });
        row.addEventListener('drop', (e) => {
          e.preventDefault();
          row.classList.remove('drag-over-above', 'drag-over-below');
          const dragId = e.dataTransfer.getData('text/plain');
          if (dragId === lane.id) return;
          const rect = row.getBoundingClientRect();
          const mid = rect.top + rect.height / 2;
          const above = e.clientY < mid;
          setState(s => {
            const fromIdx = s.swimlanes.findIndex(l => l.id === dragId);
            if (fromIdx === -1) return;
            const [moved] = s.swimlanes.splice(fromIdx, 1);
            let toIdx = s.swimlanes.findIndex(l => l.id === lane.id);
            if (!above) toIdx++;
            s.swimlanes.splice(toIdx, 0, moved);
          });
        });

        const nameEl = document.createElement('div');
        nameEl.className = 'lane-name';
        nameEl.textContent = lane.name;
        nameEl.addEventListener('click', (e) => {
          e.stopPropagation();
          const laneItems = STATE.items.filter(it => it.swimlaneId === lane.id);
          const itemCount = laneItems.length;
          const deleteMsg = itemCount > 0
            ? `Delete '${lane.name}' and ${itemCount} item(s)?`
            : `Delete '${lane.name}'?`;
          const currentMinRows = (STATE.swimlanes.find(l => l.id === lane.id) || {}).minRows || 1;
          const lastRowEmpty = !STATE.items.some(it => it.swimlaneId === lane.id && it.track >= currentMinRows - 1);
          showMenu([
            { label: 'Rename', onClick: () => startRenameLane(lane.id) },
            { separator: true },
            { label: '+ Add row', onClick: () => {
              setState(s => {
                const l = s.swimlanes.find(l => l.id === lane.id);
                if (l) l.minRows = (l.minRows || 1) + 1;
              });
            }},
            { label: '- Remove row', disabled: !lastRowEmpty || currentMinRows <= 1, onClick: () => {
              if (!lastRowEmpty || currentMinRows <= 1) return;
              setState(s => {
                const l = s.swimlanes.find(l => l.id === lane.id);
                if (l) l.minRows = Math.max(1, (l.minRows || 1) - 1);
              });
            }},
            { separator: true },
            { label: 'Delete', danger: true, onClick: () => {
              setState(s => {
                s.swimlanes = s.swimlanes.filter(l => l.id !== lane.id);
                s.items = s.items.filter(it => it.swimlaneId !== lane.id);
              });
            }},
          ], nameEl);
        });

        row.appendChild(nameEl);
        return row;
      }

      function buildSidebar(laneHeights) {
        const sidebar = document.createElement('div');
        sidebar.className = 'sidebar';

        const sideHeader = document.createElement('div');
        sideHeader.className = 'sidebar-header';
        sidebar.appendChild(sideHeader);

        const sideRows = document.createElement('div');
        sideRows.className = 'sidebar-rows';
        STATE.swimlanes.forEach((lane, idx) => {
          sideRows.appendChild(buildSidebarRow(lane, laneHeights[idx]));
        });
        sidebar.appendChild(sideRows);

        // Resize handle
        const resizeHandle = document.createElement('div');
        resizeHandle.className = 'sidebar-resize-handle';
        resizeHandle.addEventListener('pointerdown', (e) => {
          e.preventDefault();
          e.stopPropagation();
          resizeHandle.classList.add('active');
          const slide = document.getElementById('slide');
          const scale = getSlideScale();
          const startX = e.clientX;
          const startWidth = getSidebarWidth();

          function onMove(me) {
            const dx = (me.clientX - startX) / scale;
            const newWidth = Math.max(DEFAULT_SIDEBAR_W, Math.min(400, startWidth + dx));
            STATE.timeline.sidebarWidth = Math.round(newWidth);
            if (slide) {
              slide.style.setProperty('--sidebar-width', Math.round(newWidth) + 'px');
            }
          }

          function onUp() {
            resizeHandle.classList.remove('active');
            document.removeEventListener('pointermove', onMove);
            document.removeEventListener('pointerup', onUp);
            saveState();
            pushHistory(STATE);
            render();
          }

          document.addEventListener('pointermove', onMove);
          document.addEventListener('pointerup', onUp);
        });
        sidebar.appendChild(resizeHandle);

        return sidebar;
      }

      function buildItemBar(item, ctx) {
        const { tlStart, totalDays, totalWidth } = ctx;
        const itemStart = parseDate(item.startDate);
        const itemEnd = parseDate(item.endDate);
        const x1 = dateToX(itemStart, tlStart, totalDays, totalWidth);
        const x2 = dateToX(itemEnd, tlStart, totalDays, totalWidth);
        const w = Math.max(x2 - x1, MIN_BAR_WIDTH);
        const trackY = LANE_PADDING + item.track * (ITEM_BAR_H + TRACK_GAP);

        // Wrapper to hold bar + floating label
        const wrapper = document.createElement('div');
        wrapper.style.cssText = 'position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;';

        const bar = document.createElement('div');
        bar.className = 'item-bar' + (selectedItemId === item.id ? ' selected' : '');
        bar.style.left = x1 + 'px';
        bar.style.width = w + 'px';
        bar.style.top = trackY + 'px';
        bar.style.background = item.color;
        bar.style.setProperty('--bar-color', item.color);
        bar.dataset.itemId = item.id;
        bar.dataset.track = item.track;

        // Hidden text for bar sizing (no visible text in bar itself)
        const textSpan = document.createElement('span');
        textSpan.className = 'item-bar-text';
        textSpan.style.visibility = 'hidden';
        textSpan.textContent = item.name || 'Untitled';
        bar.appendChild(textSpan);


        const handleL = document.createElement('div');
        handleL.className = 'resize-handle left';
        const handleR = document.createElement('div');
        handleR.className = 'resize-handle right';
        bar.appendChild(handleL);
        bar.appendChild(handleR);

        handleL.addEventListener('pointerdown', (e) => {
          e.stopPropagation();
          startResize(e, item, 'resize-left', tlStart, totalDays, totalWidth);
        });
        handleR.addEventListener('pointerdown', (e) => {
          e.stopPropagation();
          startResize(e, item, 'resize-right', tlStart, totalDays, totalWidth);
        });

        bar.addEventListener('pointerdown', (e) => {
          if (e.target.classList.contains('resize-handle')) return;
          if (e.target.tagName === 'INPUT') return;
          e.stopPropagation();

          const startX = e.clientX;
          const startY = e.clientY;
          let moved = false;

          function onMove(me) {
            const dx = me.clientX - startX;
            const dy = me.clientY - startY;
            if (!moved && Math.abs(dx) + Math.abs(dy) > DRAG_THRESHOLD) {
              moved = true;
              document.removeEventListener('pointermove', onMove);
              document.removeEventListener('pointerup', onUp);
              startMove(e, item, tlStart, totalDays, totalWidth);
            }
          }

          function onUp() {
            document.removeEventListener('pointermove', onMove);
            document.removeEventListener('pointerup', onUp);
          }

          document.addEventListener('pointermove', onMove);
          document.addEventListener('pointerup', onUp);
        });
        bar.addEventListener('click', (e) => {
          if (dragState && dragState.moved) return;
          if (e.target.tagName === 'INPUT') return;
          e.stopPropagation();
          selectedItemId = item.id;
          render();
        });

        bar.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          e.stopPropagation();
          selectedItemId = item.id;
          showMenu([
            { label: 'Rename', onClick: () => {
              const lbl = document.querySelector(`.item-bar-label[data-item-id="${item.id}"]`);
              if (lbl) startRenameItem(item.id, lbl);
            }},
            { separator: true },
            { colors: PALETTE, selectedColor: item.color, onColorClick: (color) => {
              setState(s => {
                const it = s.items.find(i => i.id === item.id);
                if (it) it.color = color;
              });
            }},
            { separator: true },
            { label: 'Delete', danger: true, onClick: () => deleteItem(item.id) },
          ], bar);
        });

        wrapper.appendChild(bar);

        // Auto-positioned label — inside bar if text fits, outside (no bg) if not
        const labelText = item.name || 'Untitled';
        const labelPadH = LABEL_PAD_H;
        const labelH = 22;
        const textPx = measureLabelText(labelText);
        const labelW = textPx + labelPadH;
        const fitsInBar = labelW <= (w - 8);

        const label = document.createElement('div');
        label.className = 'item-bar-label';
        label.dataset.itemId = item.id;
        label.textContent = labelText;
        label.style.top = (trackY + (ITEM_BAR_H - labelH) / 2) + 'px';

        if (fitsInBar) {
          label.style.left = (x1 + 8) + 'px';
        } else {
          label.classList.add('label-overflow');
          // Prefer right of bar; fall back to left if it would overflow the timeline
          const rightPos = x2 + 6;
          if (rightPos + labelW <= totalWidth) {
            label.style.left = rightPos + 'px';
          } else {
            label.style.left = Math.max(0, x1 - 6 - labelW) + 'px';
          }
        }

        label.addEventListener('click', (e) => {
          if (e.target.tagName === 'INPUT') return;
          e.stopPropagation();
          selectedItemId = item.id;
          render();
          const lbl = document.querySelector(`.item-bar-label[data-item-id="${item.id}"]`);
          if (lbl) startRenameItem(item.id, lbl);
        });

        wrapper.appendChild(label);
        return wrapper;
      }

      function buildHeaderRow(items, ctx, height, styleFn, options = {}) {
        const { tlStart, totalDays } = ctx;
        const row = document.createElement('div');
        row.className = 'timeline-header-row' + (options.className ? ' ' + options.className : '');
        row.style.height = height + 'px';
        items.forEach((item, i) => {
          const hd = document.createElement('div');
          hd.className = 'timeline-col-header';
          hd.style.width = columnWidthPct(item, tlStart, totalDays) + '%';
          hd.style.background = styleFn(item, i, items.length);
          hd.textContent = options.labelFn ? options.labelFn(item, i) : item.label;
          row.appendChild(hd);
        });
        return row;
      }

      function buildHeader(ctx) {
        const { tlStart, tlEnd, totalDays, cols } = ctx;
        const cfg = getDisplayConfig(STATE.timeline.monthCount || 12);
        const header = document.createElement('div');
        header.className = 'timeline-header';
        const months = getMonths(tlStart, tlEnd);

        // Title row
        const titleRow = document.createElement('div');
        titleRow.className = 'timeline-header-row timeline-title-row';
        titleRow.style.height = TITLE_ROW_H + 'px';
        const titleEl = document.createElement('div');
        titleEl.className = 'timeline-title';
        titleEl.textContent = STATE.timeline.title || 'New Timeline';
        titleEl.addEventListener('click', (e) => {
          e.stopPropagation();
          showMenu([
            { label: 'Rename', onClick: () => startRenameTitle() },
          ], titleEl);
        });
        titleRow.appendChild(titleEl);

        const logo = document.createElement('img');
        logo.className = 'slide-logo';
        logo.crossOrigin = 'anonymous';
        logo.src = 'https://upload.wikimedia.org/wikipedia/commons/thumb/2/2f/Logo_of_EQ_Bank.svg/960px-Logo_of_EQ_Bank.svg.png';
        logo.alt = 'EQ Bank';
        titleRow.appendChild(logo);
        header.appendChild(titleRow);

        // Quarter row
        if (cfg.showQuarterRow) {
          header.appendChild(buildHeaderRow(cols, ctx, QUARTER_ROW_H,
            (_col, i, len) => goldRamp(len === 1 ? 1 : i / (len - 1))
          ));
        }

        // Month row
        const monthStyle = cfg.monthColorMode === 'gradient'
          ? (_m, i, len) => goldRamp(len === 1 ? 1 : i / (len - 1))
          : (_m, i) => i % 2 === 0 ? 'var(--canvas-row-even)' : 'var(--canvas-row-odd)';
        const monthLabel = cfg.useFullMonthNames
          ? (m) => MONTH_NAMES_FULL[m.start.getMonth()]
          : undefined;
        header.appendChild(buildHeaderRow(months, ctx, MONTH_ROW_H, monthStyle, { labelFn: monthLabel }));

        // Sub-month row (weeks or days)
        if (cfg.showSubMonthRow) {
          if (cfg.subMonthMode === 'day') {
            header.appendChild(buildHeaderRow(getDays(tlStart, tlEnd), ctx, WEEK_ROW_H,
              (day) => {
                const dow = day.start.getDay();
                return (dow === 0 || dow === 6) ? 'var(--_N300)' : 'var(--canvas-row-even)';
              },
              { className: 'timeline-week-header' }
            ));
          } else {
            header.appendChild(buildHeaderRow(getWeeks(tlStart, tlEnd), ctx, WEEK_ROW_H,
              (_w, i) => i % 2 === 0 ? 'var(--canvas-row-even)' : 'var(--canvas-row-odd)',
              { className: 'timeline-week-header' }
            ));
          }
        }

        return header;
      }

      function buildGrid(ctx, laneHeights) {
        const { tlStart, totalDays, totalWidth, cols } = ctx;
        const grid = document.createElement('div');
        grid.className = 'timeline-grid';
        grid.id = 'timeline-grid';
        grid.style.width = '100%';

        // Gridlines
        cols.forEach((col, i) => {
          if (i === 0) return;
          const line = document.createElement('div');
          line.className = 'gridline';
          line.style.left = (i * 100 / cols.length) + '%';
          grid.appendChild(line);
        });

        // Rows with items
        STATE.swimlanes.forEach((lane, laneIdx) => {
          const row = document.createElement('div');
          row.className = 'timeline-grid-row';
          row.dataset.laneId = lane.id;
          row.dataset.laneIdx = laneIdx;
          row.style.height = laneHeights[laneIdx] + 'px';

          STATE.items.filter(it => it.swimlaneId === lane.id).forEach(item => {
            row.appendChild(buildItemBar(item, ctx));
          });

          grid.appendChild(row);
        });

        return grid;
      }

      function buildLegend() {
        const usedColors = new Set(STATE.items.map(it => it.color));
        if (usedColors.size === 0) return null;

        const legend = document.createElement('div');
        const orientation = STATE.timeline.legendOrientation || 'vertical';
        const align = STATE.timeline.legendAlign || 'right';
        legend.className = 'timeline-legend legend-align-' + align + (orientation === 'horizontal' ? ' legend-horizontal' : '');

        PALETTE.forEach(color => {
          if (!usedColors.has(color)) return;
          const itemEl = document.createElement('div');
          itemEl.className = 'legend-item';

          const colorDot = document.createElement('div');
          colorDot.className = 'legend-color';
          colorDot.style.background = color;

          const labelEl = document.createElement('div');
          labelEl.className = 'legend-label';
          labelEl.textContent = STATE.legendLabels[color] || 'Category';
          labelEl.addEventListener('click', (e) => {
            e.stopPropagation();
            const labelName = STATE.legendLabels[color] || 'Category';
            showMenu([
              { label: 'Rename', onClick: () => startRenameLegend(color, labelEl) },
            ], labelEl);
          });

          itemEl.appendChild(colorDot);
          itemEl.appendChild(labelEl);
          legend.appendChild(itemEl);
        });

        return legend;
      }

      function buildTimelineArea(ctx, laneHeights) {
        const { tlStart, totalDays, totalWidth } = ctx;
        const tlArea = document.createElement('div');
        tlArea.className = 'timeline-area';
        tlArea.id = 'timeline-area';

        tlArea.appendChild(buildHeader(ctx));

        const grid = buildGrid(ctx, laneHeights);

        // Click-drag to create on grid
        grid.addEventListener('pointerdown', (e) => {
          if (e.target.closest('.item-bar') || e.target.closest('.item-bar-label')) return;
          if (e.button !== 0) return;
          const targetRow = e.target.closest('.timeline-grid-row');
          if (!targetRow) return;
          const laneIdx = parseInt(targetRow.dataset.laneIdx, 10);
          if (isNaN(laneIdx) || laneIdx < 0 || laneIdx >= STATE.swimlanes.length) return;
          const scale = getSlideScale();
          const gridRect = grid.getBoundingClientRect();
          const x = (e.clientX - gridRect.left) / scale;

          const startDate = xToDate(x, tlStart, totalDays, totalWidth);

          dragState = {
            type: 'create',
            laneIdx,
            startX: x,
            currentX: x,
            startDate,
            tlStart, totalDays, totalWidth,
            gridEl: grid,
            areaEl: tlArea,
            ghostEl: null,
            row: grid.querySelectorAll('.timeline-grid-row')[laneIdx]
          };

          const ghost = document.createElement('div');
          ghost.className = 'ghost-bar';
          ghost.style.height = getItemBarHeight() + 'px';
          ghost.style.left = x + 'px';
          ghost.style.width = '0px';
          dragState.row.appendChild(ghost);
          dragState.ghostEl = ghost;
        });

        tlArea.appendChild(grid);

        const legend = buildLegend();
        if (legend) tlArea.appendChild(legend);

        return tlArea;
      }

      // ---- Render ----
      function render() {
        if (dragState) return;
        const app = document.getElementById('app');
        const slide = document.getElementById('slide');
        const rowHeight = getRowHeight();
        if (slide) {
          slide.style.setProperty('--row-height', rowHeight + 'px');
          slide.style.setProperty('--item-bar-height', ITEM_BAR_H + 'px');
          slide.style.setProperty('--sidebar-width', getSidebarWidth() + 'px');
          slide.style.setProperty('--header-height', getHeaderHeight() + 'px');
        }

        app.className = 'main';
        app.innerHTML = '';

        if (STATE.swimlanes.length === 0) {
          app.appendChild(buildEmptyState());
        } else {
          const tlStart = parseDate(STATE.timeline.startDate);
          const tlEnd = parseDate(STATE.timeline.endDate);
          const totalDays = Math.max(daysBetween(tlStart, tlEnd), 1);
          const cfg = getDisplayConfig(STATE.timeline.monthCount || 12);
          const cols = getColumns(tlStart, tlEnd, cfg.topGranularity);
          const totalWidth = getTimelineWidth();
          const laneHeights = getLaneHeights();
          const ctx = { tlStart, tlEnd, totalDays, cols, totalWidth };

          app.appendChild(buildSidebar(laneHeights));
          app.appendChild(buildTimelineArea(ctx, laneHeights));
        }

        updateLengthDisplay();
        updateSlideScale();
      }

      // ---- Inline edit utility ----
      function startInlineEdit(el, currentValue, onSave, options = {}) {
        const { placeholder, autoSize } = options;
        const input = document.createElement('input');
        input.value = currentValue;
        if (placeholder) input.placeholder = placeholder;
        el.textContent = '';

        let sizer = null;
        if (autoSize) {
          sizer = document.createElement('span');
          sizer.style.cssText = 'position:absolute;visibility:hidden;white-space:pre;font:inherit;pointer-events:none;';
          el.appendChild(sizer);
          const resizeInput = () => {
            sizer.textContent = input.value || input.placeholder || '';
            input.style.width = sizer.offsetWidth + 'px';
          };
          el.appendChild(input);
          resizeInput();
          input.addEventListener('input', resizeInput);
        } else {
          el.appendChild(input);
        }

        input.focus();
        input.setSelectionRange(input.value.length, input.value.length);

        let finished = false;
        const finish = () => {
          if (finished) return;
          finished = true;
          onSave(input.value.trim());
        };

        input.addEventListener('blur', finish);
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') input.blur();
          if (e.key === 'Escape') { input.value = currentValue; input.blur(); }
        });
        input.addEventListener('pointerdown', (e) => e.stopPropagation());
      }

      // ---- Legend Rename ops ----
      function startRenameLegend(color, textEl) {
        const currentName = STATE.legendLabels[color] || 'Category';
        startInlineEdit(textEl, currentName === 'Category' ? '' : currentName, (val) => {
          setState(s => {
            if (val) { s.legendLabels[color] = val; } else { delete s.legendLabels[color]; }
          });
        }, { placeholder: 'Category', autoSize: true });
      }

      // ---- Title ops ----
      function startRenameTitle() {
        const titleEl = document.querySelector('.timeline-title');
        if (!titleEl) return;
        startInlineEdit(titleEl, STATE.timeline.title || 'New Timeline', (val) => {
          setState(s => { s.timeline.title = val || 'New Timeline'; });
        });
      }

      // ---- Item rename ----
      function startRenameItem(itemId, textEl) {
        const item = STATE.items.find(it => it.id === itemId);
        if (!item) return;
        textEl.style.background = 'transparent';
        startInlineEdit(textEl, item.name || '', (val) => {
          setState(s => {
            const it = s.items.find(i => i.id === itemId);
            if (it) it.name = val;
          });
        });
      }

      // ---- Track helpers ----
      function findFreeTrack(laneId, startDateStr, endDateStr, items) {
        const src = items || STATE.items;
        const laneItems = src.filter(it => it.swimlaneId === laneId);
        const itemStart = parseDate(startDateStr);
        const itemEnd   = parseDate(endDateStr);
        for (let t = 0; ; t++) {
          const conflict = laneItems.some(it =>
            it.track === t &&
            parseDate(it.startDate) < itemEnd &&
            parseDate(it.endDate)   > itemStart
          );
          if (!conflict) return t;
        }
      }

      // ---- Swimlane ops ----
      function addSwimlane() {
        setState(s => {
          s.swimlanes.push({ id: uid(), name: 'New Group', order: s.swimlanes.length, minRows: 1 });
        });
        // Auto-focus rename on the new lane
        setTimeout(() => {
          const rows = document.querySelectorAll('.sidebar-row');
          const last = rows[rows.length - 1];
          if (last) {
            const nameEl = last.querySelector('.lane-name');
            if (nameEl) startRenameLaneEl(nameEl, STATE.swimlanes[STATE.swimlanes.length - 1].id);
          }
        }, AUTOFOCUS_DELAY_MS);
      }

      function startRenameLane(laneId) {
        const row = document.querySelector(`.sidebar-row[data-lane-id="${laneId}"]`);
        if (!row) return;
        const nameEl = row.querySelector('.lane-name');
        startRenameLaneEl(nameEl, laneId);
      }

      function startRenameLaneEl(nameEl, laneId) {
        const lane = STATE.swimlanes.find(l => l.id === laneId);
        if (!lane) return;
        startInlineEdit(nameEl, lane.name, (val) => {
          setState(s => {
            const l = s.swimlanes.find(l => l.id === laneId);
            if (l) l.name = val || 'Untitled';
          });
        });
      }


      // ---- Context menu ----
      let activeMenu = null;

      function dismissMenu() {
        if (activeMenu) {
          activeMenu.classList.add('ctx-exit');
          const el = activeMenu;
          activeMenu = null;
          setTimeout(() => el.remove(), 100);
        }
      }

      function showMenu(items, anchorEl) {
        dismissMenu();
        const menu = document.createElement('div');
        menu.className = 'ctx-menu';

        items.forEach(item => {
          if (item.separator) {
            const sep = document.createElement('div');
            sep.className = 'ctx-menu-separator';
            menu.appendChild(sep);
            return;
          }
          if (item.colors) {
            const row = document.createElement('div');
            row.className = 'ctx-menu-colors';
            item.colors.forEach(color => {
              const sw = document.createElement('div');
              sw.className = 'ctx-menu-swatch' + (item.selectedColor === color ? ' selected' : '');
              sw.style.background = color;
              sw.addEventListener('click', () => {
                dismissMenu();
                if (item.onColorClick) item.onColorClick(color);
              });
              row.appendChild(sw);
            });
            menu.appendChild(row);
            return;
          }
          const btn = document.createElement('button');
          btn.className = 'ctx-menu-item' + (item.danger ? ' ctx-danger' : '') + (item.disabled ? ' ctx-disabled' : '');
          btn.textContent = item.label;
          if (item.disabled) btn.disabled = true;
          btn.addEventListener('click', () => {
            if (item.disabled) return;
            dismissMenu();
            if (item.onClick) item.onClick();
          });
          menu.appendChild(btn);
        });

        menu.style.visibility = 'hidden';
        menu.style.top = '0';
        menu.style.left = '0';
        document.body.appendChild(menu);

        const rect = anchorEl.getBoundingClientRect();
        const mw = menu.offsetWidth;
        const mh = menu.offsetHeight;
        const margin = 4;
        let top = rect.bottom + margin;
        if (top + mh > window.innerHeight - 8) top = rect.top - mh - margin;
        let left = rect.left;
        if (left + mw > window.innerWidth - 8) left = window.innerWidth - mw - 8;
        if (left < 8) left = 8;
        menu.style.top = top + 'px';
        menu.style.left = left + 'px';
        menu.style.visibility = '';
        activeMenu = menu;
      }

      // ---- Confirm dialog (legacy, kept for restart) ----
      function showInfo(message) {
        const overlay = document.createElement('div');
        overlay.className = 'confirm-overlay';
        const box = document.createElement('div');
        box.className = 'confirm-box';
        const p = document.createElement('p');
        p.textContent = message;
        box.appendChild(p);
        const actions = document.createElement('div');
        actions.className = 'confirm-actions';
        actions.innerHTML = '<button class="btn-cancel">OK</button>';
        box.appendChild(actions);
        overlay.appendChild(box);
        document.body.appendChild(overlay);
        box.querySelector('.btn-cancel').onclick = () => overlay.remove();
        overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.remove(); });
      }

      function showConfirm(message, onConfirm) {
        const overlay = document.createElement('div');
        overlay.className = 'confirm-overlay';
        const box = document.createElement('div');
        box.className = 'confirm-box';
        const p = document.createElement('p');
        p.textContent = message;
        box.appendChild(p);
        const actions = document.createElement('div');
        actions.className = 'confirm-actions';
        actions.innerHTML = '<button class="btn-cancel">Cancel</button><button class="btn-danger">Delete</button>';
        box.appendChild(actions);
        overlay.appendChild(box);
        document.body.appendChild(overlay);

        box.querySelector('.btn-cancel').onclick = () => overlay.remove();
        box.querySelector('.btn-danger').onclick = () => { overlay.remove(); onConfirm(); };
        overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.remove(); });
      }

      // ---- Drag handlers (strategy pattern) ----
      function handleCreateDrag(e, ds, scale) {
        const gridRect = ds.gridEl.getBoundingClientRect();
        const x = (e.clientX - gridRect.left) / scale;
        ds.currentX = x;

        const left = Math.min(ds.startX, x);
        const right = Math.max(ds.startX, x);
        const snappedStart = snapToMonday(xToDate(left, ds.tlStart, ds.totalDays, ds.totalWidth));
        const snappedEnd = snapToMonday(xToDate(right, ds.tlStart, ds.totalDays, ds.totalWidth));

        const snappedLeft = dateToX(snappedStart, ds.tlStart, ds.totalDays, ds.totalWidth);
        const snappedRight = dateToX(snappedEnd, ds.tlStart, ds.totalDays, ds.totalWidth);

        if (ds.ghostEl) {
          ds.ghostEl.style.left = snappedLeft + 'px';
          ds.ghostEl.style.width = Math.abs(snappedRight - snappedLeft) + 'px';
        }
        showDragTooltip(`${formatDateForTooltip(snappedStart)} - ${formatDateForTooltip(snappedEnd)}`, e.clientX, e.clientY);
      }

      function handleMoveDrag(e, ds, scale) {
        ds.moved = true;
        const gridRect = ds.gridEl.getBoundingClientRect();
        const x = (e.clientX - gridRect.left) / scale;
        const y = (e.clientY - gridRect.top) / scale;
        const dx = x - ds.startMouseX;
        const dy = y - ds.startMouseY;

        ds.barEl.style.transform = `translate(${dx}px, calc(-2px + ${dy}px))`;

        const rawLeft = ds.origLeft + dx;
        const snappedStartDate = snapToMonday(xToDate(rawLeft, ds.tlStart, ds.totalDays, ds.totalWidth));
        ds.newStartDate = snappedStartDate;
        showDragTooltip(formatDateForTooltip(snappedStartDate), e.clientX, e.clientY);

        const baseLaneHeights = getLaneHeights();
        const EXTRA = ITEM_BAR_H + TRACK_GAP;
        // Expand the previously-hovered lane so the cursor can reach a new track slot
        const prevLaneIdx = ds.currentLaneIdx ?? 0;
        const effectiveHeights = baseLaneHeights.map((h, i) => i === prevLaneIdx ? h + EXTRA : h);

        let cumulativeY = 0;
        let newLaneIdx = baseLaneHeights.length - 1;
        let newTrack = 0;

        for (let i = 0; i < effectiveHeights.length; i++) {
          if (y < cumulativeY + effectiveHeights[i]) {
            newLaneIdx = i;
            const trackY = (y - cumulativeY) - LANE_PADDING;
            newTrack = Math.max(0, Math.floor(trackY / (ITEM_BAR_H + TRACK_GAP)));
            break;
          }
          cumulativeY += effectiveHeights[i];
        }

        ds.currentLaneIdx = newLaneIdx;
        ds.currentTrack = newTrack;

        const rows = ds.gridEl.querySelectorAll('.timeline-grid-row');
        rows.forEach((r, i) => {
          r.classList.remove('drag-over-active');
          r.style.height = baseLaneHeights[i] + 'px';
        });
        if (rows[newLaneIdx]) {
          rows[newLaneIdx].classList.add('drag-over-active');
          rows[newLaneIdx].style.height = (baseLaneHeights[newLaneIdx] + EXTRA) + 'px';
        }
      }

      function handleResizeDrag(e, ds, scale) {
        ds.moved = true;
        const gridRect = ds.gridEl.getBoundingClientRect();
        const x = (e.clientX - gridRect.left) / scale;
        const rawDate = xToDate(x, ds.tlStart, ds.totalDays, ds.totalWidth);
        const snappedX = dateToX(snapToMonday(rawDate), ds.tlStart, ds.totalDays, ds.totalWidth);

        if (ds.type === 'resize-left') {
          const newLeft = Math.min(snappedX, ds.origRight - MIN_BAR_WIDTH);
          ds.barEl.style.left = newLeft + 'px';
          ds.barEl.style.width = (ds.origRight - newLeft) + 'px';
          ds.newStartDate = snapToMonday(xToDate(newLeft, ds.tlStart, ds.totalDays, ds.totalWidth));
          showDragTooltip(formatDateForTooltip(ds.newStartDate), e.clientX, e.clientY);
        } else {
          const newRight = Math.max(snappedX, ds.origLeft + MIN_BAR_WIDTH);
          ds.barEl.style.width = (newRight - ds.origLeft) + 'px';
          ds.newEndDate = snapToMonday(xToDate(newRight, ds.tlStart, ds.totalDays, ds.totalWidth));
          showDragTooltip(formatDateForTooltip(ds.newEndDate), e.clientX, e.clientY);
        }
      }

      const dragHandlers = {
        create: handleCreateDrag,
        move: handleMoveDrag,
        'resize-left': handleResizeDrag,
        'resize-right': handleResizeDrag,
      };

      document.addEventListener('pointermove', (e) => {
        if (!dragState) return;
        const handler = dragHandlers[dragState.type];
        if (handler) handler(e, dragState, getSlideScale());
      });

      document.addEventListener('pointerup', (e) => {
        if (!dragState) return;
        const ds = dragState;
        dragState = null;
        hideDragTooltip();

        // Check if dragged then clear transform & clean up active highlight
        if (ds.barEl) {
          ds.barEl.classList.remove('dragging');
          ds.barEl.style.transform = ''; // Reset the free drag transform
        }
        document.querySelectorAll('.drag-over-active').forEach(r => r.classList.remove('drag-over-active'));
        document.querySelectorAll('.timeline-grid-row').forEach(r => r.style.height = '');

        if (ds.type === 'create') {
          if (ds.ghostEl) ds.ghostEl.remove();
          const width = Math.abs(ds.currentX - ds.startX);
          if (width < DRAG_THRESHOLD) return; // too small, ignore

          const left = Math.min(ds.startX, ds.currentX);
          const right = Math.max(ds.startX, ds.currentX);
          const rawStartDate = xToDate(left, ds.tlStart, ds.totalDays, ds.totalWidth);
          const rawEndDate = xToDate(right, ds.tlStart, ds.totalDays, ds.totalWidth);

          // Snap to weeks
          const startDate = snapToMonday(rawStartDate);
          const endDate = snapToMonday(rawEndDate);

          // Ensure at least 1 week
          if (daysBetween(startDate, endDate) < 7) {
            endDate.setDate(endDate.getDate() + 7);
          }

          const lane = STATE.swimlanes[ds.laneIdx];
          if (!lane) return;

          const newItem = {
            id: uid(),
            swimlaneId: lane.id,
            name: '',
            startDate: fmt(startDate),
            endDate: fmt(endDate),
            color: PALETTE[STATE.items.length % PALETTE.length],
            track: findFreeTrack(lane.id, fmt(startDate), fmt(endDate))
          };

          selectedItemId = newItem.id;
          setState(s => {
            s.items.push(newItem);
          });
        } else if (ds.type === 'move' && ds.moved) {
          // Use the snapped start date from dragState (calculated during mousemove)
          const newStartDate = ds.newStartDate;
          const origStart = parseDate(ds.item.startDate);
          const origEnd = parseDate(ds.item.endDate);
          const duration = daysBetween(origStart, origEnd);
          const newEndDate = addDays(newStartDate, duration);

          const newLane = STATE.swimlanes[ds.currentLaneIdx];

          setState(s => {
            const it = s.items.find(i => i.id === ds.item.id);
            if (it) {
              it.startDate = fmt(newStartDate);
              it.endDate = fmt(newEndDate);
              if (newLane) it.swimlaneId = newLane.id;
              if (ds.currentTrack !== undefined) it.track = ds.currentTrack;
            }
          });
        } else if ((ds.type === 'resize-left' || ds.type === 'resize-right') && ds.moved) {
          setState(s => {
            const it = s.items.find(i => i.id === ds.item.id);
            if (!it) return;
            if (ds.type === 'resize-left' && ds.newStartDate) {
              it.startDate = fmt(ds.newStartDate);
            } else if (ds.type === 'resize-right' && ds.newEndDate) {
              it.endDate = fmt(ds.newEndDate);
            }
            // Ensure start < end
            if (parseDate(it.startDate) >= parseDate(it.endDate)) {
              it.endDate = fmt(addDays(parseDate(it.startDate), 1));
            }
          });
        }
      });

      function startMove(e, item, tlStart, totalDays, totalWidth) {
        const bar = e.target.closest('.item-bar');
        if (!bar) return;

        const grid = document.getElementById('timeline-grid');
        const area = document.getElementById('timeline-area');
        const scale = getSlideScale();
        const gridRect = grid.getBoundingClientRect();

        dragState = {
          type: 'move',
          item,
          barEl: bar,
          gridEl: grid,
          areaEl: area,
          startMouseX: (e.clientX - gridRect.left) / scale,
          startMouseY: (e.clientY - gridRect.top) / scale,
          origLeft: parseFloat(bar.style.left),
          currentLaneIdx: STATE.swimlanes.findIndex(l => l.id === item.swimlaneId),
          tlStart, totalDays, totalWidth,
          moved: false
        };
        bar.classList.add('dragging');
      }

      function startResize(e, item, type, tlStart, totalDays, totalWidth) {
        const bar = e.target.closest('.item-bar');
        const grid = document.getElementById('timeline-grid');
        const area = document.getElementById('timeline-area');

        dragState = {
          type,
          item,
          barEl: bar,
          gridEl: grid,
          areaEl: area,
          origLeft: parseFloat(bar.style.left),
          origRight: parseFloat(bar.style.left) + parseFloat(bar.style.width),
          tlStart, totalDays, totalWidth,
          moved: false,
          newStartDate: null,
          newEndDate: null
        };
      }


      // ---- Item delete ----
      function deleteItem(itemId) {
        if (selectedItemId === itemId) selectedItemId = null;
        setState(s => { s.items = s.items.filter(it => it.id !== itemId); });
      }

      document.addEventListener('keydown', (e) => {
        // Only trigger global shortcuts if not typing in an input
        if (document.activeElement.tagName === 'INPUT') {
          // Input bindings are handled elsewhere (like esc/enter)
          return;
        }

        // Undo: Ctrl+Z or Cmd+Z
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z' && !e.shiftKey) {
          e.preventDefault();
          undo();
          return;
        }

        // Redo: Ctrl+Y or Cmd+Y or Ctrl+Shift+Z or Cmd+Shift+Z
        if ((e.ctrlKey || e.metaKey) && (e.key.toLowerCase() === 'y' || (e.key.toLowerCase() === 'z' && e.shiftKey))) {
          e.preventDefault();
          redo();
          return;
        }

        // Delete item
        if (selectedItemId && (e.key === 'Delete' || e.key === 'Backspace')) {
          deleteItem(selectedItemId);
        }
      });

      // ---- Control sidebar events ----
      document.getElementById('btn-undo').addEventListener('click', undo);
      document.getElementById('btn-redo').addEventListener('click', redo);
      document.getElementById('btn-add-swimlane').addEventListener('click', addSwimlane);

      // Timeline length slider
      function updateLengthDisplay() {
        const el = document.getElementById('length-display');
        const slider = document.getElementById('length-slider');
        const mc = STATE.timeline.monthCount || 12;
        if (el) el.textContent = mc + ' mo';
        if (slider) slider.value = mc;
      }

      document.getElementById('length-slider').addEventListener('input', (e) => {
        const val = parseInt(e.target.value, 10);
        setState(s => {
          s.timeline.monthCount = val;
          updateTimelineDates();
        });
        const el = document.getElementById('length-display');
        if (el) el.textContent = val + ' mo';
      });

      document.getElementById('btn-add-item').addEventListener('click', () => {
        if (STATE.swimlanes.length === 0) {
          showInfo('Please add a group first.');
          return;
        }
        // Add item to first swimlane with default 1-week duration
        const tlStart = parseDate(STATE.timeline.startDate);
        const startDate = snapToMonday(new Date());
        const endDate = addDays(startDate, 28);

        setState(s => {
          const newItem = {
            id: uid(),
            swimlaneId: s.swimlanes[0].id,
            name: 'New Initiative',
            startDate: fmt(startDate),
            endDate: fmt(endDate),
            color: PALETTE[s.items.length % PALETTE.length],
            track: findFreeTrack(s.swimlanes[0].id, fmt(startDate), fmt(endDate), s.items)
          };
          s.items.push(newItem);
          selectedItemId = newItem.id;
        });
      });

      function exportCSV() {
        const laneMap = {};
        STATE.swimlanes.forEach(l => { laneMap[l.id] = l.name; });
        const escape = (v) => '"' + String(v).replace(/"/g, '""') + '"';
        const rows = [['Group', 'Initiative', 'Start Date', 'End Date'].map(escape).join(',')];
        STATE.items.forEach(item => {
          rows.push([
            escape(laneMap[item.swimlaneId] || ''),
            escape(item.name || ''),
            escape(item.startDate),
            escape(item.endDate)
          ].join(','));
        });
        const blob = new Blob([rows.join('\n')], { type: 'text/csv' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'timeline.csv';
        a.click();
        URL.revokeObjectURL(a.href);
      }

      // Legend layout toggles
      function updateLegendToggleUI() {
        const isHorizontal = STATE.timeline.legendOrientation === 'horizontal';
        document.getElementById('btn-legend-vertical').classList.toggle('btn-active', !isHorizontal);
        document.getElementById('btn-legend-horizontal').classList.toggle('btn-active', isHorizontal);
        const align = STATE.timeline.legendAlign || 'right';
        ['left', 'center', 'right'].forEach(a => {
          document.getElementById('btn-legend-' + a).classList.toggle('btn-active', align === a);
        });
      }

      document.getElementById('btn-legend-vertical').addEventListener('click', () => {
        setState(s => { s.timeline.legendOrientation = 'vertical'; });
        updateLegendToggleUI();
      });
      document.getElementById('btn-legend-horizontal').addEventListener('click', () => {
        setState(s => { s.timeline.legendOrientation = 'horizontal'; });
        updateLegendToggleUI();
      });
      ['left', 'center', 'right'].forEach(align => {
        document.getElementById('btn-legend-' + align).addEventListener('click', () => {
          setState(s => { s.timeline.legendAlign = align; });
          updateLegendToggleUI();
        });
      });

      document.getElementById('btn-export').addEventListener('click', exportPNG);
      document.getElementById('btn-export-csv').addEventListener('click', exportCSV);

      document.getElementById('btn-reset').addEventListener('click', () => {
        showConfirm('Reset to blank slate? This will delete all groups and initiatives.', () => {
          STATE = defaultState();
          selectedItemId = null;
          saveState();
          render();
        });
      });

      // Deselect on click outside
      document.addEventListener('click', (e) => {
        if (activeMenu && !e.target.closest('.ctx-menu')) dismissMenu();
        if (!e.target.closest('.item-bar') && !e.target.closest('.item-bar-label') && !e.target.closest('.ctx-menu')) {
          if (selectedItemId) {
            selectedItemId = null;
            render();
          }
        }
      });

      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') dismissMenu();
      });

      // ---- PNG Export ----
      async function exportPNG() {
        const slide = document.getElementById('slide');
        const savedTransform = slide.style.transform;
        slide.style.transform = 'none';
        try {
          const canvas = await html2canvas(slide, { scale: 2, useCORS: true });
          canvas.toBlob((blob) => {
            if (!blob) { showInfo('Export failed.'); return; }
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'timeline.png';
            a.click();
            URL.revokeObjectURL(a.href);
          }, 'image/png');
        } catch (err) {
          console.error('Export failed:', err);
          showInfo('Export failed. See console for details.');
        } finally {
          slide.style.transform = savedTransform;
        }
      }

      // ---- Init ----
      loadState();
      updateLengthDisplay();
      updateLegendToggleUI();
      render();
      window.addEventListener('resize', updateSlideScale);

    })();
  </script>
</body>

</html>